package weblab;

import java.util.*;

class Solution {

  public static /**
   * @param n the number of jobs
   * @param m the number of processors
   * @param deadlines the deadlines of the jobs 1 through n. NB: you should ignore deadlines[0]
   * @return the minimised maximum lateness.
   */
  int solve(int n, int m, int[] deadlines) {
    int maxLateness = maxLatenessSorting(n, m, deadlines);
    return maxLateness;
  }

  public static int maxLatenessPriorityQueue(int n, int m, int[] deadlines) {
    PriorityQueue<Job> queue = new PriorityQueue<>();
    for (int i = 1; i <= n; i++) {
      queue.add(new Job(deadlines[i]));
    }
    int maxLateness = Integer.MIN_VALUE;
    int processorIndex = 1;
    int t = 0;
    while (!queue.isEmpty()) {
      Job job = queue.poll();
      int lateness = t + 1 - job.deadline;
      if (maxLateness < lateness) {
        maxLateness = lateness;
      }
      if (processorIndex + 1 <= m) {
        processorIndex = processorIndex + 1;
      } else {
        t = t + 1;
        processorIndex = 1;
      }
    }
    return maxLateness;
  }

  public static int inefficientSorting(int n, int m, int[] deadlines) {
    ArrayList<Job> jobList = new ArrayList<>(n);
    for (int i = 1; i <= n; i++) {
      jobList.add(new Job(deadlines[i]));
    }
    for (int i = 0; i < n; i++) {
      for (int j = 1; j < (n - i); j++) {
        if (jobList.get(j - 1).deadline > jobList.get(j).deadline) {
          Job temp = jobList.get(j - 1);
          jobList.set(j - 1, jobList.get(j));
          jobList.set(j, temp);
        }
      }
    }
    int maxLateness = Integer.MIN_VALUE;
    int processorIndex = 1;
    int t = 0;
    for (int i = 0; i < jobList.size(); i++) {
      Job job = jobList.get(i);
      int lateness = t + 1 - job.deadline;
      if (maxLateness < lateness) {
        maxLateness = lateness;
      }
      if (processorIndex + 1 <= m) {
        processorIndex = processorIndex + 1;
      } else {
        t = t + 1;
        processorIndex = 1;
      }
    }
    return maxLateness;
  }

  public static int maxLatenessSorting(int n, int m, int[] deadlines) {
    ArrayList<Job> jobList = new ArrayList<>(n);
    for (int i = 1; i <= n; i++) {
      jobList.add(new Job(deadlines[i]));
    }
    Collections.sort(jobList);
    int maxLateness = Integer.MIN_VALUE;
    int processorIndex = 1;
    int t = 0;
    for (int i = 0; i < jobList.size(); i++) {
      Job job = jobList.get(i);
      int lateness = t + 1 - job.deadline;
      if (maxLateness < lateness) {
        maxLateness = lateness;
      }
      if (processorIndex + 1 <= m) {
        processorIndex = processorIndex + 1;
      } else {
        t = t + 1;
        processorIndex = 1;
      }
    }
    return maxLateness;
  }

  static class Job implements Comparable<Job> {

    public int deadline;

    public Job(int deadline) {
      this.deadline = deadline;
    }

    @Override
    public int compareTo(Job otherJob) {
      return deadline - otherJob.deadline;
    }
  }
}
