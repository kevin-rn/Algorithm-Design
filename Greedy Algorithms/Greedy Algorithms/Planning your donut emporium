package weblab;

import java.io.*;
import java.util.*;

class Solution {

  // Implement the solve method to return the answer to the problem posed by the inputstream.
  public static String run(InputStream in) {
    return new Solution().solve(in);
  }

  public String solve(InputStream in) {
    Scanner sc = new Scanner(in);
    int n = sc.nextInt();
    int k = sc.nextInt();
    List<House> houses = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
      houses.add(new House(i, sc.nextInt(), sc.nextInt()));
    }
    int m = n * (n - 1) / 2;
    List<Distance> distances = new ArrayList<>(m);
    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        distances.add(new Distance(houses.get(i), houses.get(j)));
      }
    }
    UnionFind unionFind = new UnionFind(houses);
    {
      // Sort by shortest distance
      distances.sort(Comparator.comparingLong(d -> d.distance));
      int count = 0;
      for (Distance d : distances) {
        if (count == n - k)
          break;
        if (unionFind.join(d.a, d.b))
          count++;
      }
      StringBuilder res = new StringBuilder();
      for (List<House> cluster : unionFind.clusters()) {
        long c = 0, sumX = 0, sumY = 0;
        for (House house : cluster) {
          c++;
          sumX += house.x;
          sumY += house.y;
        }
        // Adding 1e-6 to test if it's accepted
        res.append((double) sumX / c + 1e-6).append(' ').append((double) sumY / c).append('\n');
      }
      return res.toString();
    }
  }
}

/*
//___________________________________________________________________________________________________________________________
package weblab;

import static org.junit.Assert.*;
import java.io.*;
import java.nio.charset.*;
import java.util.*;
import org.junit.*;
import org.junit.rules.*;

public class UTest {

  private long time = 0;

  @Rule
  public TestName name = new TestName();

  @Before
  public void setUp() {
    time = System.currentTimeMillis();
  }

  @After
  public void tearDown() {
    System.out.println("Test '" + name.getMethodName() + "' took " + (System.currentTimeMillis() - time) + "ms");
  }

  static class Store implements Comparable<Store> {

    double x, y;

    public Store(double x, double y) {
      this.x = x;
      this.y = y;
    }

    public Store(String s) {
      String[] split = s.split(" ");
      x = Double.parseDouble(split[0]);
      y = Double.parseDouble(split[1]);
    }

    @Override
    public int compareTo(Store store) {
      return Comparator.<Store>comparingDouble(s -> s.x).thenComparingDouble(s -> s.y).compare(this, store);
    }
  }

  private static void runTestWithFile(String fileName) {
    assertApproximatelyEquals(WebLab.getData(fileName + ".out").trim(), Solution.run(new ByteArrayInputStream(WebLab.getData(fileName + ".in").getBytes(StandardCharsets.UTF_8))).trim());
  }

  // Sorts the resulting stores by coordinate (so order doesn't matter) and checks whether it's within 1e-6 error
  private static void assertApproximatelyEquals(String expected, String actual) {
    String[] expectedStrings = expected.split("\n");
    String[] actualStrings = actual.split("\n");
    if (expectedStrings.length != actualStrings.length)
      throw new ComparisonFailure("Lengths of lists different!", Integer.toString(expectedStrings.length), Integer.toString(actualStrings.length));
    Store[] expectedStores = Arrays.stream(expectedStrings).map(Store::new).sorted().toArray(Store[]::new);
    Store[] actualStores = Arrays.stream(actualStrings).map(Store::new).sorted().toArray(Store[]::new);
    for (int i = 0; i < actualStores.length; i++) {
      Store s1 = expectedStores[i], s2 = actualStores[i];
      assertEquals("x-coordinate of store " + i, s1.x, s2.x, s1.x * 1e-6);
      assertEquals("y-coordinate of store " + i, s1.y, s2.y, s1.y * 1e-6);
    }
  }

  private static void runSmallTest(String in, String out) {
    assertApproximatelyEquals(out.trim(), Solution.run(new ByteArrayInputStream(in.getBytes(StandardCharsets.UTF_8))).trim());
  }

  @Test(timeout = 100)
  public void example() {
    runTestWithFile("example");
  }

  @Test(timeout = 100)
  public void oneHouse() {
    runSmallTest("1 1\n1 1", "1 1");
  }

  @Test(timeout = 100)
  public void twoHousesOneCluster() {
    runSmallTest("2 1\n1 1\n3 3", "2 2");
  }

  @Test(timeout = 100)
  public void twoHousesTwoClusters() {
    runSmallTest("2 2\n1 1\n3 3", "1 1\n3 3");
  }

  @Test(timeout = 100)
  public void threeHousesTwoClusters() {
    runSmallTest("3 2\n1 1\n3 3\n4 4", "1 1\n3.5 3.5");
  }

  @Test(timeout = 100)
  public void floaters() {
    runSmallTest("3 1\n1 1\n1 1\n2 2", "1.333333333333333 1.333333333333333");
  }

  @Test(timeout = 2000)
  public void n1000k3() {
    runTestWithFile("1000points3clusters");
  }

  @Test(timeout = 2000)
  public void n1000k500() {
    runTestWithFile("1000points500clusters");
  }
}
*/
