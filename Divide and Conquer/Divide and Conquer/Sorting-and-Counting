package weblab;

import java.io.*;

class Solution {

  static int countInversions(int[] array) {
    return sortAndCount(array, 0, array.length - 1);
  }

  public static // Sort input array using recursion and return number of inversions
  int sortAndCount(int[] array, int left, int right) {
    int inversions = 0;
    int mid;
    if (right > left) {
      // Divide array into two parts and do mergeAndCount sort on both parts
      mid = (right + left) / 2;
      // Inversions are the sum of left-part inversions, right-part inversions,
      // and inversions during merging
      inversions = sortAndCount(array, left, mid);
      inversions += sortAndCount(array, mid + 1, right);
      inversions += mergeAndCount(array, left, mid + 1, right);
    }
    return inversions;
  }

  public static // Merge two sorted arrays and return number of inversions that occurred.
  int mergeAndCount(int[] array, int left, int mid, int right) {
    int inversions = 0;
    int[] temp = new int[array.length];
    // i is index for left subarray
    int i = left;
    // j is index for right subarray
    int j = mid;
    // k is index for merged subarrays
    int k = left;
    while ((i <= mid - 1) && (j <= right)) {
      if (array[i] <= array[j]) {
        temp[k++] = array[i++];
      } else {
        temp[k++] = array[j++];
        inversions = inversions + (mid - i);
      }
    }
    // Copy remaining elements of left subarray to temp
    while (i <= mid - 1) {
      temp[k++] = array[i++];
    }
    // Copy remaining elements of right subarray to temp
    while (j <= right) {
      temp[k++] = array[j++];
    }
    // Copy back merged elements to original array.
    for (i = left; i <= right; i++) {
      array[i] = temp[i];
    }
    return inversions;
  }
}

//____________________________________________________________________________________________________________

package weblab;

import static org.junit.Assert.assertEquals;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import org.junit.*;
import org.junit.rules.*;

public class UTest {

  private long time = 0;

  @Rule
  public TestName name = new TestName();

  @Before
  public void setUp() {
    time = System.currentTimeMillis();
  }

  @After
  public void tearDown() {
    System.out.println("Test '" + name.getMethodName() + "' took " + (System.currentTimeMillis() - time) + "ms");
  }

  private static int[] parseInput(String in) {
    Scanner sc = new Scanner(in);
    int arrayLength = sc.nextInt();
    int[] arrayToSort = new int[arrayLength];
    for (int i = 0; i < arrayLength; i++) {
      arrayToSort[i] = sc.nextInt();
    }
    sc.close();
    return arrayToSort;
  }

  private static void runTestWithFile(String fileName) {
    int[] input = parseInput(WebLab.getData(fileName + ".in"));
    int expected = Integer.parseInt(WebLab.getData(fileName + ".out"));
    assertEquals(expected, Solution.countInversions(input));
  }

  @Test(timeout = 100)
  public void countInversions() {
    int[] input = { 2, 1, 0, 8 };
    assertEquals(3, Solution.countInversions(input));
  }

  @Test(timeout = 100)
  public void noInvertions() {
    runTestWithFile("example2");
  }

  @Test(timeout = 100)
  public void worstCaseInvertions() {
    runTestWithFile("example3");
  }

  @Test(timeout = 100)
  public void emptyArray() {
    runTestWithFile("example4");
  }

  @Test(timeout = 100)
  public void evenArray() {
    runTestWithFile("example5");
  }

  @Test(timeout = 100)
  public void unevenArray() {
    runTestWithFile("example6");
  }

  @Test(timeout = 100)
  public void negativeNumbersInArray() {
    runTestWithFile("example7");
  }

  @Test(timeout = 100)
  public void duplicatesInArray1() {
    runTestWithFile("example8");
  }

  @Test(timeout = 100)
  public void duplicatesInArray2() {
    runTestWithFile("example9");
  }

  @Test(timeout = 100)
  public void allTheSame() {
    runTestWithFile("example10");
  }

  @Test(timeout = 100)
  public void oneElement() {
    runTestWithFile("example11");
  }

  @Test(timeout = 1000)
  public void largeList() {
    runTestWithFile("example12");
  }

  @Test(timeout = 1800)
  public void veryLargeList() {
    runTestWithFile("example13");
  }
}
